from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
import argparse

@dataclass
class QueryItem:
    qid: str
    text: str

@dataclass
class ReformulationResult:
    qid: str
    original: str
    reformulated: str
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class MethodConfig:
    name: str
    params: Dict[str, Any]
    llm: Dict[str, Any]
    seed: int = 42
    retries: int = 2

class BaseReformulator:
    VERSION = "0.1"
    REQUIRES_CONTEXT = False
    
    # Concatenation strategy configuration
    CONCATENATION_STRATEGY = "query_repeat_plus_generated"  # Default strategy
    DEFAULT_QUERY_REPEATS = 3  # Default number of query repetitions

    def __init__(self, cfg: MethodConfig, llm_client, prompt_resolver):
        self.cfg = cfg
        self.llm = llm_client
        self.prompts = prompt_resolver

    def reformulate(self, q: QueryItem, contexts: Optional[List[str]] = None) -> ReformulationResult:
        raise NotImplementedError

    def concatenate_result(self, original_query: str, generated_content: str | List[str], 
                          query_repeats: Optional[int] = None, 
                          content_separator: str = " ") -> str:
        """
        Concatenate the original query with generated content based on the method's strategy.
        Matches exact patterns from baseline implementations.
        
        Args:
            original_query: The original query text
            generated_content: The content generated by the LLM (string or list of strings)
            query_repeats: Number of times to repeat the original query (overrides default)
            content_separator: Separator to use between multiple content pieces
        
        Returns:
            Concatenated reformulated query
        """
        if query_repeats is None:
            query_repeats = self.cfg.params.get("repeat_query_weight", self.DEFAULT_QUERY_REPEATS)
        
        strategy = self.cfg.params.get("concatenation_strategy", self.CONCATENATION_STRATEGY)
        
        # Handle multiple content pieces
        if isinstance(generated_content, list):
            generated_text = content_separator.join(generated_content)
        else:
            generated_text = generated_content
        
        if strategy == "query_repeat_plus_generated":
            # Pattern: (Q × N) + generated_content
            # Used by: GenQR, GenQREnsemble, QA-Expand
            result = " ".join([original_query] * query_repeats + [generated_text])
        
        elif strategy == "query_plus_generated":
            # Pattern: Q + generated_content (single repetition)
            # Used by: Query2E
            result = " ".join([original_query, generated_text])
        
        elif strategy == "generated_only":
            # Pattern: Only generated content (no original query)
            # Used by: Query2Doc
            result = generated_text
        
        elif strategy == "adaptive_query_repeat_plus_generated":
            # Pattern: (query + ' ') * repetition_times + generated_content
            # Uses adaptive repetition based on content length
            # Used by: MuGI
            adaptive_times = self.cfg.params.get("adaptive_times", 5)
            repetition_times = (len(generated_text) // len(original_query)) // adaptive_times
            repetition_times = max(1, repetition_times)  # At least 1 repetition
            result = (original_query + " ") * repetition_times + generated_text
        
        elif strategy == "interleaved_query_content":
            # Pattern: q + a1 + q + a2 + q + a3 + ... (interleaving)
            # Used by: LameR
            if isinstance(generated_content, list):
                expanded_parts = []
                for passage in generated_content:
                    expanded_parts.append(original_query)
                    expanded_parts.append(passage)
                result = " ".join(expanded_parts)
            else:
                # Single content: query + content
                result = " ".join([original_query, generated_text])
        
        elif strategy == "generated_plus_query_repeat":
            # Pattern: generated_content + (Q × N)
            # Used by: Future methods that want generated content first
            result = " ".join([generated_text] + [original_query] * query_repeats)
        
        elif strategy == "query_sandwich":
            # Pattern: Q + generated_content + Q
            # Used by: Future methods that want query wrapping
            result = " ".join([original_query, generated_text, original_query])
        
        else:
            # Default fallback to query_repeat_plus_generated pattern
            result = " ".join([original_query] * query_repeats + [generated_text])
        
        # Clean up any newlines and quotes in the final result
        result = result.replace('\n', ' ').replace('\r', ' ').strip()
        # Remove quotes from beginning and end
        result = result.strip('"').strip("'")
        return result

    def retrieve_contexts_batch(self, queries: List[QueryItem], retrieval_params: Optional[Dict[str, Any]] = None) -> Dict[str, List[str]]:
        """Retrieve contexts for a batch of queries via any searcher implementing BaseSearcher.
        
        Args:
            queries: List of QueryItem objects to retrieve contexts for
            retrieval_params: Method-specific retrieval parameters (searcher_type, searcher_kwargs, k, etc.)
            
        Returns:
            Dictionary mapping query IDs to lists of context strings
        """
        if not retrieval_params or not queries:
            return {}
            
        # Extract searcher configuration
        searcher_type = retrieval_params.get("searcher_type", "pyserini")
        searcher_kwargs = retrieval_params.get("searcher_kwargs", {})
        k = retrieval_params.get("k", 10)
        threads = retrieval_params.get("threads", 16)
        answer_key = retrieval_params.get("answer_key", "contents")

        # Lazy import to avoid hard dependency at load time
        try:
            from .retriever import Retriever  # type: ignore
        except Exception:
            return {}

        # Create retriever with searcher configuration
        retriever = Retriever(
            searcher_type=searcher_type,
            searcher_kwargs=searcher_kwargs,
            answer_key=answer_key
        )
        
        # Extract query texts and IDs
        query_texts = [q.text for q in queries]
        query_ids = [q.qid for q in queries]
        
        # Perform batch retrieval
        batch_results = retriever.retrieve_batch(query_texts, k, threads)
        
        # Convert results to dictionary format
        contexts = {}
        for qid, results in zip(query_ids, batch_results):
            # Extract only the text contents
            contexts[qid] = [content for _docid, content in results]
        
        return contexts

    def retrieve_contexts_if_needed(self, q: QueryItem, retrieval_params: Optional[Dict[str, Any]] = None) -> List[str]:
        """Retrieve contexts for a single query (fallback method).
        
        Args:
            q: QueryItem to retrieve contexts for
            retrieval_params: Method-specific retrieval parameters
            
        Returns:
            List of context strings
        """
        contexts = self.retrieve_contexts_batch([q], retrieval_params)
        return contexts.get(q.qid, [])

    def reformulate_batch(self, queries: List[QueryItem], ctx_map: Optional[Dict[str, List[str]]] = None):
        # If no contexts provided and method requires context, do batch retrieval
        if ctx_map is None and hasattr(self, 'REQUIRES_CONTEXT') and self.REQUIRES_CONTEXT:
            retrieval_params = self._get_retrieval_params()
            if retrieval_params:
                ctx_map = self.retrieve_contexts_batch(queries, retrieval_params)
        
        out: List[ReformulationResult] = []
        
        # Import tqdm for progress bar
        try:
            from tqdm import tqdm
            progress_bar = tqdm(queries, desc=f"Reformulating with {self.cfg.name}", unit="query")
        except ImportError:
            # Fallback if tqdm is not available
            progress_bar = queries
        
        for q in progress_bar:
            ctx = (ctx_map or {}).get(q.qid)
            result = self.reformulate(q, ctx)
            out.append(result)
            
            # Update progress bar description with current query info
            if hasattr(progress_bar, 'set_description'):
                progress_bar.set_description(f"Reformulating with {self.cfg.name} (QID: {q.qid})")
        
        return out
    
    def _get_retrieval_params(self) -> Optional[Dict[str, Any]]:
        """Get retrieval parameters for this method. Override in subclasses."""
        return None
