from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from tqdm import tqdm

@dataclass
class QueryItem:
    qid: str
    text: str

@dataclass
class ReformulationResult:
    qid: str
    original: str
    reformulated: str
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class MethodConfig:
    name: str
    params: Dict[str, Any]
    llm: Dict[str, Any]
    seed: int = 42
    retries: int = 2

class BaseReformulator:
    VERSION = "0.1"
    REQUIRES_CONTEXT = False
    
    # Concatenation strategy configuration
    CONCATENATION_STRATEGY = "query_repeat_plus_generated"  # Default strategy
    DEFAULT_QUERY_REPEATS = 3  # Default number of query repetitions

    def __init__(self, cfg: MethodConfig, llm_client, prompt_resolver):
        self.cfg = cfg
        self.llm = llm_client
        self.prompts = prompt_resolver

    def reformulate(self, q: QueryItem, contexts: Optional[List[str]] = None) -> ReformulationResult:
        raise NotImplementedError

    def concatenate_result(self, original_query: str, generated_content: str | List[str], 
                          query_repeats: Optional[int] = None, 
                          content_separator: str = " ") -> str:
        """
        Concatenate the original query with generated content based on the method's strategy.
        Matches exact patterns from baseline implementations.
        
        Args:
            original_query: The original query text
            generated_content: The content generated by the LLM (string or list of strings)
            query_repeats: Number of times to repeat the original query (overrides default)
            content_separator: Separator to use between multiple content pieces
        
        Returns:
            Concatenated reformulated query
        """
        if query_repeats is None:
            query_repeats = self.cfg.params.get("repeat_query_weight", self.DEFAULT_QUERY_REPEATS)
        
        strategy = self.cfg.params.get("concatenation_strategy", self.CONCATENATION_STRATEGY)
        
        # Handle multiple content pieces
        if isinstance(generated_content, list):
            generated_text = content_separator.join(generated_content)
        else:
            generated_text = generated_content
        
        if strategy == "query_repeat_plus_generated":
            # Pattern: (Q × N) + generated_content
            # Used by: GenQR, GenQREnsemble, QA-Expand
            result = " ".join([original_query] * query_repeats + [generated_text])
        
        elif strategy == "query_plus_generated":
            # Pattern: Q + generated_content (single repetition)
            # Used by: Query2E
            result = " ".join([original_query, generated_text])
        
        elif strategy == "generated_only":
            # Pattern: Only generated content (no original query)
            # Used by: Query2Doc
            result = generated_text
        
        elif strategy == "adaptive_query_repeat_plus_generated":
            # Pattern: (query + ' ') * repetition_times + generated_content
            # Uses adaptive repetition based on content length
            # Used by: MuGI
            adaptive_times = self.cfg.params.get("adaptive_times", 5)
            repetition_times = (len(generated_text) // len(original_query)) // adaptive_times
            repetition_times = max(1, repetition_times)  # At least 1 repetition
            result = (original_query + " ") * repetition_times + generated_text
        
        elif strategy == "interleaved_query_content":
            # Pattern: q + a1 + q + a2 + q + a3 + ... (interleaving)
            # Used by: LameR
            if isinstance(generated_content, list):
                expanded_parts = []
                for passage in generated_content:
                    expanded_parts.append(original_query)
                    expanded_parts.append(passage)
                result = " ".join(expanded_parts)
            else:
                # Single content: query + content
                result = " ".join([original_query, generated_text])
        
        elif strategy == "generated_plus_query_repeat":
            # Pattern: generated_content + (Q × N)
            # Used by: Future methods that want generated content first
            result = " ".join([generated_text] + [original_query] * query_repeats)
        
        elif strategy == "query_sandwich":
            # Pattern: Q + generated_content + Q
            # Used by: Future methods that want query wrapping
            result = " ".join([original_query, generated_text, original_query])
        
        else:
            # Default fallback to query_repeat_plus_generated pattern
            result = " ".join([original_query] * query_repeats + [generated_text])
        
        # Clean up any newlines and quotes in the final result (for non-newline strategies)
        result = result.replace('\n', ' ').replace('\r', ' ').strip()
        # Remove quotes from beginning and end
        result = result.strip('"').strip("'")
        return result

    def retrieve_contexts_batch(self, queries: List[QueryItem], retrieval_params: Optional[Dict[str, Any]] = None) -> Dict[str, List[str]]:
        """Retrieve contexts for a batch of queries via any searcher implementing BaseSearcher.
        
        This method supports both searcher adapters (via registry) and wrapped searchers:
        
        **Using Adapters (via searcher_type):**
            retrieval_params = {
                "searcher_type": "pyserini",  # or "pyterrier"
                "searcher_kwargs": {"index": "msmarco-v1-passage", ...},
                "k": 10,
                "threads": 16,
            }
        
        **Using Wrapped Searchers:**
            # Wrap your existing searcher
            from pyserini.search.lucene import LuceneSearcher
            my_searcher = LuceneSearcher.from_prebuilt_index('msmarco-v1-passage')
            wrapped = wrap_pyserini_searcher(my_searcher)
            
            retrieval_params = {
                "searcher": wrapped,  # Pass wrapped searcher directly
                "k": 10,
                "threads": 16,
            }
        
        **Using Adapter Instances Directly:**
            from queryGym import create_searcher
            searcher = create_searcher("pyserini", index="msmarco-v1-passage")
            
            retrieval_params = {
                "searcher": searcher,  # Pass adapter instance directly
                "k": 10,
            }
        
        Args:
            queries: List of QueryItem objects to retrieve contexts for
            retrieval_params: Method-specific retrieval parameters. Can include:
                - searcher: Pre-existing BaseSearcher instance (wrappers, adapters, or custom)
                - searcher_type: Type of searcher to create via registry ("pyserini", "pyterrier", etc.)
                - searcher_kwargs: Keyword arguments to pass to searcher constructor
                - k: Number of documents to retrieve per query (default: 10)
                - threads: Number of threads for batch search (default: 16)
            
        Returns:
            Dictionary mapping query IDs to lists of context strings
        """
        if not retrieval_params or not queries:
            return {}
        
        # Extract retrieval configuration
        k = retrieval_params.get("k", 10)
        threads = retrieval_params.get("threads", 16)
        
        # Get or create searcher
        searcher = retrieval_params.get("searcher")
        
        if searcher is None:
            # Create searcher using registry
            searcher_type = retrieval_params.get("searcher_type", "pyserini")
            searcher_kwargs = retrieval_params.get("searcher_kwargs", {})
            
            # Lazy import to avoid hard dependency at load time
            try:
                from .searcher import create_searcher
                searcher = create_searcher(searcher_type, **searcher_kwargs)
            except Exception as e:
                # If searcher creation fails, return empty dict
                # This allows methods to work without retrieval if contexts are pre-provided
                return {}
        
        # Ensure searcher implements BaseSearcher interface
        from .searcher import BaseSearcher
        if not isinstance(searcher, BaseSearcher):
            raise ValueError(
                f"Searcher must implement BaseSearcher interface. "
                f"Got type: {type(searcher)}"
            )
        
        # Extract query texts and IDs
        query_texts = [q.text for q in queries]
        query_ids = [q.qid for q in queries]
        
        # Perform batch retrieval using searcher's batch_search method
        batch_results = searcher.batch_search(query_texts, k=k, num_threads=threads)
        
        # Convert SearchHit results to dictionary format (qid -> list of context strings)
        contexts = {}
        for qid, search_hits in zip(query_ids, batch_results):
            # Extract content from each SearchHit
            contexts[qid] = [hit.content for hit in search_hits]
        
        return contexts

    def retrieve_contexts_if_needed(self, q: QueryItem, retrieval_params: Optional[Dict[str, Any]] = None) -> List[str]:
        """Retrieve contexts for a single query (fallback method).
        
        Args:
            q: QueryItem to retrieve contexts for
            retrieval_params: Method-specific retrieval parameters
            
        Returns:
            List of context strings
        """
        contexts = self.retrieve_contexts_batch([q], retrieval_params)
        return contexts.get(q.qid, [])

    def reformulate_batch(self, queries: List[QueryItem], ctx_map: Optional[Dict[str, List[str]]] = None):
        # If no contexts provided and method requires context, do batch retrieval
        if ctx_map is None and hasattr(self, 'REQUIRES_CONTEXT') and self.REQUIRES_CONTEXT:
            retrieval_params = self._get_retrieval_params()
            if retrieval_params:
                ctx_map = self.retrieve_contexts_batch(queries, retrieval_params)
        
        out: List[ReformulationResult] = []
        
        # Import tqdm for progress bar
        try:
            progress_bar = tqdm(queries, desc=f"Reformulating with {self.cfg.name}", unit="query")
        except ImportError:
            # Fallback if tqdm is not available
            progress_bar = queries
        
        for q in progress_bar:
            ctx = (ctx_map or {}).get(q.qid)
            result = self.reformulate(q, ctx)
            out.append(result)
            
            # Update progress bar description with current query info
            if hasattr(progress_bar, 'set_description'):
                progress_bar.set_description(f"Reformulating with {self.cfg.name} (QID: {q.qid})")
        
        return out
    
    def _get_retrieval_params(self) -> Optional[Dict[str, Any]]:
        """Get retrieval parameters for this method. Override in subclasses."""
        return None
