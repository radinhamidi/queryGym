from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any

@dataclass
class QueryItem:
    qid: str
    text: str

@dataclass
class ReformulationResult:
    qid: str
    original: str
    reformulated: str
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class MethodConfig:
    name: str
    params: Dict[str, Any]
    llm: Dict[str, Any]
    seed: int = 42
    retries: int = 2

class BaseReformulator:
    VERSION = "0.1"
    REQUIRES_CONTEXT = False
    
    # Concatenation strategy configuration
    CONCATENATION_STRATEGY = "query_repeat_plus_generated"  # Default strategy
    DEFAULT_QUERY_REPEATS = 3  # Default number of query repetitions

    def __init__(self, cfg: MethodConfig, llm_client, prompt_resolver):
        self.cfg = cfg
        self.llm = llm_client
        self.prompts = prompt_resolver

    def reformulate(self, q: QueryItem, contexts: Optional[List[str]] = None) -> ReformulationResult:
        raise NotImplementedError

    def concatenate_result(self, original_query: str, generated_content: str | List[str], 
                          query_repeats: Optional[int] = None, 
                          content_separator: str = " ") -> str:
        """
        Concatenate the original query with generated content based on the method's strategy.
        Matches exact patterns from baseline implementations.
        
        Args:
            original_query: The original query text
            generated_content: The content generated by the LLM (string or list of strings)
            query_repeats: Number of times to repeat the original query (overrides default)
            content_separator: Separator to use between multiple content pieces
        
        Returns:
            Concatenated reformulated query
        """
        if query_repeats is None:
            query_repeats = self.cfg.params.get("repeat_query_weight", self.DEFAULT_QUERY_REPEATS)
        
        strategy = self.cfg.params.get("concatenation_strategy", self.CONCATENATION_STRATEGY)
        
        # Handle multiple content pieces
        if isinstance(generated_content, list):
            generated_text = content_separator.join(generated_content)
        else:
            generated_text = generated_content
        
        if strategy == "query_repeat_plus_generated":
            # Pattern: (Q × N) + generated_content
            # Used by: GenQR, GenQREnsemble, QA-Expand
            return " ".join([original_query] * query_repeats + [generated_text])
        
        elif strategy == "query_plus_generated":
            # Pattern: Q + generated_content (single repetition)
            # Used by: Query2E
            return " ".join([original_query, generated_text])
        
        elif strategy == "generated_only":
            # Pattern: Only generated content (no original query)
            # Used by: Query2Doc
            return generated_text
        
        elif strategy == "adaptive_query_repeat_plus_generated":
            # Pattern: (query + ' ') * repetition_times + generated_content
            # Uses adaptive repetition based on content length
            # Used by: MuGI
            adaptive_times = self.cfg.params.get("adaptive_times", 5)
            repetition_times = (len(generated_text) // len(original_query)) // adaptive_times
            repetition_times = max(1, repetition_times)  # At least 1 repetition
            enhanced_query = (original_query + " ") * repetition_times + generated_text
            # Normalize whitespace: remove any newline characters introduced by generation
            enhanced_query = enhanced_query.replace('\n', ' ').replace('\r', ' ').strip()
            return enhanced_query
        
        elif strategy == "interleaved_query_content":
            # Pattern: q + a1 + q + a2 + q + a3 + ... (interleaving)
            # Used by: LameR
            if isinstance(generated_content, list):
                expanded_parts = []
                for passage in generated_content:
                    expanded_parts.append(original_query)
                    expanded_parts.append(passage)
                return " ".join(expanded_parts)
            else:
                # Single content: query + content
                return " ".join([original_query, generated_text])
        
        elif strategy == "generated_plus_query_repeat":
            # Pattern: generated_content + (Q × N)
            # Used by: Future methods that want generated content first
            return " ".join([generated_text] + [original_query] * query_repeats)
        
        elif strategy == "query_sandwich":
            # Pattern: Q + generated_content + Q
            # Used by: Future methods that want query wrapping
            return " ".join([original_query, generated_text, original_query])
        
        else:
            # Default fallback to query_repeat_plus_generated pattern
            return " ".join([original_query] * query_repeats + [generated_text])

    def reformulate_batch(self, queries: List[QueryItem], ctx_map: Optional[Dict[str, List[str]]] = None):
        out: List[ReformulationResult] = []
        for q in queries:
            ctx = (ctx_map or {}).get(q.qid)
            out.append(self.reformulate(q, ctx))
        return out
